<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Infinity Fountain QR</title>
    <!-- QR Code Generator -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <!-- QR Code Scanner -->
    <script src="https://unpkg.com/html5-qrcode" type="text/javascript"></script>

    <style>
        :root {
            --bg-color: #121212;
            --box-bg: #1e1e1e;
            --primary: #00ff41;
            --dim: #008f11;
            --text: #e0e0e0;
            --border: #333;
        }

        body {
            font-family: 'Courier New', Courier, monospace;
            background: var(--bg-color);
            color: var(--text);
            max-width: 800px;
            margin: 0 auto;
            padding: 10px;
            box-sizing: border-box;
        }

        h1,
        h2,
        h3 {
            color: var(--primary);
            text-shadow: 0 0 5px rgba(0, 255, 65, 0.3);
            margin-top: 0;
        }

        h1 {
            font-size: 1.5rem;
            text-align: center;
            border-bottom: 2px solid var(--dim);
            padding-bottom: 10px;
        }

        h2 {
            font-size: 1.2rem;
            margin-bottom: 10px;
            border-left: 3px solid var(--primary);
            padding-left: 10px;
        }

        .box {
            background: var(--box-bg);
            padding: 15px;
            border: 1px solid var(--border);
            margin-bottom: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }

        textarea {
            width: 100%;
            height: 80px;
            background: #000;
            color: var(--primary);
            border: 1px solid var(--dim);
            font-family: monospace;
            padding: 8px;
            box-sizing: border-box;
            border-radius: 4px;
            resize: vertical;
        }

        .controls {
            display: flex;
            gap: 10px;
            margin-top: 10px;
            flex-wrap: wrap;
        }

        button {
            flex: 1;
            background: #003300;
            color: var(--primary);
            border: 1px solid var(--primary);
            padding: 12px;
            font-weight: bold;
            cursor: pointer;
            text-transform: uppercase;
            border-radius: 4px;
            min-width: 120px;
            transition: all 0.2s;
        }

        button:hover {
            background: var(--primary);
            color: #000;
            box-shadow: 0 0 10px var(--primary);
        }

        button:disabled {
            border-color: #555;
            color: #555;
            background: #222;
            cursor: not-allowed;
            box-shadow: none;
        }

        button.stop {
            border-color: #ff4444;
            color: #ff4444;
            background: #330000;
        }

        button.stop:hover {
            background: #ff4444;
            color: #fff;
        }

        /* TX Styles */
        #qr-display {
            margin: 20px auto;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #fff;
            padding: 10px;
            width: fit-content;
            border-radius: 4px;
            min-height: 200px;
            min-width: 200px;
        }

        /* RX Styles */
        #reader {
            width: 100%;
            background: #000;
            border-radius: 4px;
            overflow: hidden;
            border: 1px solid var(--dim);
            /* Important for mobile scanner visibility */
            min-height: 300px;
        }

        .bar-container {
            width: 100%;
            background: #333;
            height: 20px;
            margin-top: 10px;
            border-radius: 10px;
            overflow: hidden;
            border: 1px solid #555;
        }

        .bar-fill {
            height: 100%;
            background: var(--primary);
            width: 0%;
            transition: width 0.3s;
            box-shadow: 0 0 10px var(--primary);
        }

        .stats {
            margin-top: 5px;
            font-size: 0.8rem;
            opacity: 0.8;
            font-family: sans-serif;
        }

        .error-log {
            color: #ff6b6b;
            font-size: 0.9rem;
            margin-top: 5px;
            border-left: 2px solid #ff6b6b;
            padding-left: 8px;
            display: none;
        }

        /* Matrix Visualization */
        #blockVis {
            margin-top: 10px;
            line-height: 0;
            max-height: 100px;
            overflow-y: auto;
            background: #000;
            padding: 5px;
            border: 1px solid #333;
        }

        .solved-block {
            display: inline-block;
            width: 6px;
            height: 6px;
            background: #222;
            margin: 1px;
        }

        .solved-block.done {
            background: var(--primary);
            box-shadow: 0 0 2px var(--primary);
        }
    </style>
</head>

<body>

    <h1>‚ôæÔ∏è Fountain Stream</h1>

    <!-- TRANSMITTER SECTION -->
    <div class="box">
        <h2>1. Transmitter</h2>
        <textarea id="txInput" placeholder="Enter data to stream...">This is a Fountain Code (LT Code) test. 

It splits this message into chunks, XORs them randomly, and sprays them out as QR codes. 
The receiver catches random droplets to reconstruct the original message.</textarea>

        <div style="margin-top:10px; display:flex; align-items:center; gap:10px;">
            <label for="fpsRange">Speed (FPS):</label>
            <input type="range" id="fpsRange" min="2" max="30" value="10" style="flex:1">
            <span id="fpsVal" style="width:30px">10</span>
        </div>

        <div class="controls">
            <button id="btnStartTx">Start Stream</button>
            <button id="btnStopTx" class="stop" disabled>Stop</button>
        </div>

        <div id="qr-display">
            <span style="color:#000; font-family:sans-serif; font-size:0.8rem;">QR Code Area</span>
        </div>
        <div class="stats" id="txStats">Status: Idle</div>
    </div>

    <!-- RECEIVER SECTION -->
    <div class="box">
        <h2>2. Receiver</h2>

        <div id="reader"></div>
        <div id="cameraError" class="error-log"></div>

        <div class="controls">
            <button id="btnScan">Activate Camera</button>
            <button id="btnStopScan" class="stop" style="display:none;">Stop Cam</button>
        </div>

        <div class="bar-container">
            <div id="rxBar" class="bar-fill"></div>
        </div>
        <div class="stats" id="rxStats">Waiting for signal...</div>

        <!-- Block visualization grid -->
        <div id="blockVis"></div>

        <h3>Reconstructed Output:</h3>
        <textarea id="rxOutput" readonly placeholder="Decoded text will appear here..."></textarea>
    </div>

    <script>
        // ==========================================
        // UTILITIES
        // ==========================================

        // Mulberry32 PRNG - Critical for deterministic recreation of XOR combinations
        function mulberry32(a) {
            return function () {
                var t = a += 0x6D2B79F5;
                t = Math.imul(t ^ (t >>> 15), t | 1);
                t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
                return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
            }
        }

        function xorArrays(a, b) {
            const len = Math.min(a.length, b.length);
            const res = new Uint8Array(len);
            for (let i = 0; i < len; i++) res[i] = a[i] ^ b[i];
            return res;
        }

        function strToBytes(str) { return new TextEncoder().encode(str); }
        function bytesToStr(arr) { return new TextDecoder().decode(arr); }

        // ==========================================
        // TRANSMITTER LOGIC
        // ==========================================
        const CHUNK_SIZE = 48; // Smaller chunks = more QR density, good for mobile
        let txInterval = null;

        const uiTx = {
            input: document.getElementById('txInput'),
            btnStart: document.getElementById('btnStartTx'),
            btnStop: document.getElementById('btnStopTx'),
            qrDiv: document.getElementById('qr-display'),
            stats: document.getElementById('txStats'),
            fps: document.getElementById('fpsRange'),
            fpsVal: document.getElementById('fpsVal')
        };

        uiTx.fps.oninput = e => uiTx.fpsVal.innerText = e.target.value;

        uiTx.btnStart.addEventListener('click', () => {
            const text = uiTx.input.value.trim();
            if (!text) return alert("Please enter some text");

            const bytes = strToBytes(text);

            // Pad to align with CHUNK_SIZE
            const totalLen = Math.ceil(bytes.length / CHUNK_SIZE) * CHUNK_SIZE;
            const paddedBytes = new Uint8Array(totalLen);
            paddedBytes.set(bytes);

            // Split into Source Blocks
            const sourceBlocks = [];
            for (let i = 0; i < totalLen; i += CHUNK_SIZE) {
                sourceBlocks.push(paddedBytes.slice(i, i + CHUNK_SIZE));
            }
            const K = sourceBlocks.length;

            // UI Update
            uiTx.btnStart.disabled = true;
            uiTx.btnStop.disabled = false;
            uiTx.input.disabled = true;

            let seq = 0;
            const speed = parseInt(uiTx.fps.value);

            txInterval = setInterval(() => {
                seq++;

                // 1. Generate Header Info
                const seed = Math.floor(Math.random() * 999999);
                const rng = mulberry32(seed);

                // 2. Determine Soliton Degree (how many blocks to mix)
                // Simplified Soliton: weighted random
                let degree = 1;
                const r = rng();
                // 50% chance of degree 1 (helps bootstrap), 50% chance of complex mix
                if (r > 0.5 && K > 1) {
                    degree = 2 + Math.floor(rng() * (K - 1));
                }

                // 3. Select unique indices based on seed
                let indices = [];
                let pool = Array.from({ length: K }, (_, i) => i);
                for (let i = 0; i < degree; i++) {
                    const pick = Math.floor(rng() * pool.length);
                    indices.push(pool[pick]);
                    pool.splice(pick, 1);
                }

                // 4. Create the droplet payload (XOR the blocks)
                let mixedBlock = new Uint8Array(CHUNK_SIZE); // initialized to 0s
                for (let idx of indices) {
                    mixedBlock = xorArrays(mixedBlock, sourceBlocks[idx]);
                }

                // 5. Pack: K, Seed, Base64Data
                // Converting binary to Base64 safely
                const binaryString = String.fromCharCode.apply(null, mixedBlock);
                const b64 = btoa(binaryString);
                const packet = `${K},${seed},${b64}`;

                // 6. Render QR
                uiTx.qrDiv.innerHTML = "";
                new QRCode(uiTx.qrDiv, {
                    text: packet,
                    width: 200,
                    height: 200,
                    correctLevel: QRCode.CorrectLevel.L // Low error correction is faster/smaller
                });

                uiTx.stats.innerText = `Streaming... Seq: ${seq} | Mix Degree: ${degree}`;

            }, 1000 / speed);
        });

        uiTx.btnStop.addEventListener('click', () => {
            clearInterval(txInterval);
            uiTx.btnStart.disabled = false;
            uiTx.btnStop.disabled = true;
            uiTx.input.disabled = false;
            uiTx.stats.innerText = "Stopped.";
        });

        // ==========================================
        // RECEIVER LOGIC
        // ==========================================
        let rxK = 0;
        let rxSolved = [];
        let rxDroplets = [];
        let html5QrCode;

        function logError(msg) {
            const el = document.getElementById('cameraError');
            el.innerHTML = msg; // Changed to innerHTML for bold tags
            el.style.display = 'block';
        }

        function initReceiver(k) {
            if (rxK === k) return;
            rxK = k;
            rxSolved = new Array(k).fill(null);
            rxDroplets = [];

            // Draw Grid
            const vis = document.getElementById('blockVis');
            vis.innerHTML = '';
            for (let i = 0; i < k; i++) {
                let d = document.createElement('div');
                d.className = 'solved-block';
                d.id = `blk-${i}`;
                vis.appendChild(d);
            }
            updateProgress();
        }

        function processQR(text) {
            try {
                const parts = text.split(',');
                if (parts.length !== 3) return; // invalid format

                const k = parseInt(parts[0]);
                const seed = parseInt(parts[1]);

                // Convert B64 back to Uint8Array
                const binStr = atob(parts[2]);
                const data = new Uint8Array(binStr.length);
                for (let i = 0; i < binStr.length; i++) data[i] = binStr.charCodeAt(i);

                if (rxK === 0) initReceiver(k);
                if (k !== rxK) return; // Mismatched stream

                // Re-derive the indices used by sender
                const rng = mulberry32(seed);
                let degree = 1;
                const r = rng();
                if (r > 0.5 && k > 1) {
                    degree = 2 + Math.floor(rng() * (k - 1));
                }

                let indices = [];
                let pool = Array.from({ length: k }, (_, i) => i);
                for (let i = 0; i < degree; i++) {
                    const pick = Math.floor(rng() * pool.length);
                    indices.push(pool[pick]);
                    pool.splice(pick, 1);
                }

                solveDroplet(indices, data);

            } catch (err) {
                console.warn("Bad Packet", err);
            }
        }

        // The "Peeling" Algorithm
        function solveDroplet(indices, data) {
            // 1. Remove already known info from this droplet
            let unknownIndices = [];
            let cleanData = data;

            for (let idx of indices) {
                if (rxSolved[idx] !== null) {
                    // We know this part, subtract (XOR) it out
                    cleanData = xorArrays(cleanData, rxSolved[idx]);
                } else {
                    unknownIndices.push(idx);
                }
            }

            if (unknownIndices.length === 0) return; // Redundant droplet

            // Store reduced droplet
            rxDroplets.push({ indices: unknownIndices, data: cleanData });

            // 2. Check if we can solve anything new (Degree 1)
            rippleSolve();
        }

        function rippleSolve() {
            let progress = true;
            while (progress) {
                progress = false;

                // Look for degree 1 droplets
                for (let i = 0; i < rxDroplets.length; i++) {
                    const d = rxDroplets[i];
                    if (d.indices.length === 1) {
                        const idx = d.indices[0];
                        // Verify we haven't solved it in this pass yet
                        if (rxSolved[idx] === null) {
                            // We found a block!
                            rxSolved[idx] = d.data;
                            document.getElementById(`blk-${idx}`).classList.add('done');
                            progress = true;

                            // Peel this new knowledge from ALL other droplets
                            peel(idx, d.data);
                        }
                    }
                }

                // Cleanup solved droplets to keep array small
                rxDroplets = rxDroplets.filter(d => d.indices.length > 0);
            }
            updateProgress();
        }

        function peel(solvedIdx, solvedBlock) {
            for (let d of rxDroplets) {
                const pos = d.indices.indexOf(solvedIdx);
                if (pos !== -1) {
                    d.data = xorArrays(d.data, solvedBlock);
                    d.indices.splice(pos, 1);
                }
            }
        }

        function updateProgress() {
            if (rxK === 0) return;
            const solvedCount = rxSolved.filter(x => x !== null).length;
            const pct = (solvedCount / rxK) * 100;

            const bar = document.getElementById('rxBar');
            bar.style.width = pct + "%";
            document.getElementById('rxStats').innerText = `Progress: ${solvedCount}/${rxK} blocks (${Math.round(pct)}%)`;

            if (solvedCount === rxK) {
                bar.style.backgroundColor = "#00ff41";
                bar.style.boxShadow = "0 0 15px #00ff41";
                reconstruct();
            }
        }

        function reconstruct() {
            let fullBytes = new Uint8Array(rxK * CHUNK_SIZE);
            for (let i = 0; i < rxK; i++) {
                fullBytes.set(rxSolved[i], i * CHUNK_SIZE);
            }
            // Decode and trim nulls
            let str = bytesToStr(fullBytes);
            str = str.replace(/\0/g, '');
            document.getElementById('rxOutput').value = str;
        }

        // ==========================================
        // CAMERA HANDLING (Mobile Fixes)
        // ==========================================

        document.getElementById('btnScan').addEventListener('click', startCamera);
        document.getElementById('btnStopScan').addEventListener('click', stopCamera);

        function startCamera() {
            document.getElementById('cameraError').style.display = 'none';

            html5QrCode = new Html5Qrcode("reader");

            // Config: Removed aspectRatio to prevent constraint errors on some mobiles
            const config = {
                fps: 30,
                qrbox: { width: 250, height: 250 }
            };

            // "environment" is the rear camera
            html5QrCode.start({ facingMode: "environment" }, config, (decodedText) => {
                processQR(decodedText);
            })
                .then(() => {
                    document.getElementById('btnScan').style.display = 'none';
                    document.getElementById('btnStopScan').style.display = 'inline-block';
                    document.getElementById('rxStats').innerText = "Camera active. Scanning...";
                })
                .catch(err => {
                    console.error(err);
                    let errorMsg = "Camera Error: " + err;

                    // detailed diagnostics
                    const isSecure = location.protocol === 'https:' || location.hostname === 'localhost' || location.hostname === '127.0.0.1';

                    if (err?.name === "NotAllowedError" || err?.toString().includes("Permission")) {
                        errorMsg = "üö´ Permission Denied. Please reset browser permissions.";
                        if (!isSecure) {
                            errorMsg += "<br><br><b>‚ö†Ô∏è IMPORTANT:</b> Mobile browsers BLOCK camera access on insecure (HTTP) sites. You MUST use HTTPS.";
                        }
                    } else if (err?.name === "NotFoundError") {
                        errorMsg = "üì∑ No camera found.";
                    } else if (err?.name === "NotReadableError") {
                        errorMsg = "‚ö†Ô∏è Camera is in use by another app or hardware error.";
                    }

                    logError(errorMsg);
                });
        }

        function stopCamera() {
            if (html5QrCode) {
                html5QrCode.stop().then(() => {
                    html5QrCode.clear();
                    document.getElementById('btnScan').style.display = 'inline-block';
                    document.getElementById('btnStopScan').style.display = 'none';
                    document.getElementById('rxStats').innerText = "Camera stopped.";
                }).catch(err => console.log(err));
            }
        }

    </script>
</body>

</html>